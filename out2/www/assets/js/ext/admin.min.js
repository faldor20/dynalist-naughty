"use strict";
!(function e(n, r) {
  (window.EXT = window.EXT || {}), (window.EXT[n] = r);
})(
  "sourceMap",
  (function (r) {
    function t(e) {
      if (o[e]) return o[e].exports;
      var n = (o[e] = { exports: {}, id: e, loaded: !1 });
      return r[e].call(n.exports, n, n.exports, t), (n.loaded = !0), n.exports;
    }
    var o = {};
    return (t.m = r), (t.c = o), (t.p = ""), t(0);
  })([
    function (e, n, r) {
      (n.SourceMapGenerator = r(1).SourceMapGenerator),
        (n.SourceMapConsumer = r(7).SourceMapConsumer),
        (n.SourceNode = r(10).SourceNode);
    },
    function (e, n, r) {
      function i(e) {
        e || (e = {}),
          (this._file = f.getArg(e, "file", null)),
          (this._sourceRoot = f.getArg(e, "sourceRoot", null)),
          (this._skipValidation = f.getArg(e, "skipValidation", !1)),
          (this._sources = new t()),
          (this._names = new t()),
          (this._mappings = new o()),
          (this._sourcesContents = null);
      }
      var h = r(2),
        f = r(4),
        t = r(5).ArraySet,
        o = r(6).MappingList;
      (i.prototype._version = 3),
        (i.fromSourceMap = function (r) {
          var t = r.sourceRoot,
            o = new i({ file: r.file, sourceRoot: t });
          return (
            r.eachMapping(function (e) {
              var n = {
                generated: { line: e.generatedLine, column: e.generatedColumn },
              };
              null != e.source &&
                ((n.source = e.source),
                null != t && (n.source = f.relative(t, n.source)),
                (n.original = {
                  line: e.originalLine,
                  column: e.originalColumn,
                }),
                null != e.name && (n.name = e.name)),
                o.addMapping(n);
            }),
            r.sources.forEach(function (e) {
              var n = r.sourceContentFor(e);
              null != n && o.setSourceContent(e, n);
            }),
            o
          );
        }),
        (i.prototype.addMapping = function (e) {
          var n = f.getArg(e, "generated"),
            r = f.getArg(e, "original", null),
            t = f.getArg(e, "source", null),
            o = f.getArg(e, "name", null);
          this._skipValidation || this._validateMapping(n, r, t, o),
            null == t || this._sources.has(t) || this._sources.add(t),
            null == o || this._names.has(o) || this._names.add(o),
            this._mappings.add({
              generatedLine: n.line,
              generatedColumn: n.column,
              originalLine: null != r && r.line,
              originalColumn: null != r && r.column,
              source: t,
              name: o,
            });
        }),
        (i.prototype.setSourceContent = function (e, n) {
          var r = e;
          null != this._sourceRoot && (r = f.relative(this._sourceRoot, r)),
            null != n
              ? (this._sourcesContents || (this._sourcesContents = {}),
                (this._sourcesContents[f.toSetString(r)] = n))
              : this._sourcesContents &&
                (delete this._sourcesContents[f.toSetString(r)],
                0 === Object.keys(this._sourcesContents).length &&
                  (this._sourcesContents = null));
        }),
        (i.prototype.applySourceMap = function (o, e, i) {
          var s = e;
          if (null == e) {
            if (null == o.file)
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.',
              );
            s = o.file;
          }
          var a = this._sourceRoot;
          null != a && (s = f.relative(a, s));
          var u = new t(),
            l = new t();
          this._mappings.unsortedForEach(function (e) {
            if (e.source === s && null != e.originalLine) {
              var n = o.originalPositionFor({
                line: e.originalLine,
                column: e.originalColumn,
              });
              null != n.source &&
                ((e.source = n.source),
                null != i && (e.source = f.join(i, e.source)),
                null != a && (e.source = f.relative(a, e.source)),
                (e.originalLine = n.line),
                (e.originalColumn = n.column),
                null != n.name && (e.name = n.name));
            }
            var r = e.source;
            null == r || u.has(r) || u.add(r);
            var t = e.name;
            null == t || l.has(t) || l.add(t);
          }, this),
            (this._sources = u),
            (this._names = l),
            o.sources.forEach(function (e) {
              var n = o.sourceContentFor(e);
              null != n &&
                (null != i && (e = f.join(i, e)),
                null != a && (e = f.relative(a, e)),
                this.setSourceContent(e, n));
            }, this);
        }),
        (i.prototype._validateMapping = function (e, n, r, t) {
          if (
            (!(
              e &&
              "line" in e &&
              "column" in e &&
              0 < e.line &&
              0 <= e.column
            ) ||
              n ||
              r ||
              t) &&
            !(
              e &&
              "line" in e &&
              "column" in e &&
              n &&
              "line" in n &&
              "column" in n &&
              0 < e.line &&
              0 <= e.column &&
              0 < n.line &&
              0 <= n.column &&
              r
            )
          )
            throw new Error(
              "Invalid mapping: " +
                JSON.stringify({
                  generated: e,
                  source: r,
                  original: n,
                  name: t,
                }),
            );
        }),
        (i.prototype._serializeMappings = function () {
          for (
            var e,
              n,
              r,
              t = 0,
              o = 1,
              i = 0,
              s = 0,
              a = 0,
              u = 0,
              l = "",
              c = this._mappings.toArray(),
              g = 0,
              p = c.length;
            g < p;
            g++
          ) {
            if ((e = c[g]).generatedLine !== o)
              for (t = 0; e.generatedLine !== o; ) (l += ";"), o++;
            else if (0 < g) {
              if (!f.compareByGeneratedPositionsInflated(e, c[g - 1])) continue;
              l += ",";
            }
            (l += h.encode(e.generatedColumn - t)),
              (t = e.generatedColumn),
              null != e.source &&
                ((r = this._sources.indexOf(e.source)),
                (l += h.encode(r - u)),
                (u = r),
                (l += h.encode(e.originalLine - 1 - s)),
                (s = e.originalLine - 1),
                (l += h.encode(e.originalColumn - i)),
                (i = e.originalColumn),
                null != e.name &&
                  ((n = this._names.indexOf(e.name)),
                  (l += h.encode(n - a)),
                  (a = n)));
          }
          return l;
        }),
        (i.prototype._generateSourcesContent = function (e, r) {
          return e.map(function (e) {
            if (!this._sourcesContents) return null;
            null != r && (e = f.relative(r, e));
            var n = f.toSetString(e);
            return Object.prototype.hasOwnProperty.call(
              this._sourcesContents,
              n,
            )
              ? this._sourcesContents[n]
              : null;
          }, this);
        }),
        (i.prototype.toJSON = function () {
          var e = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings(),
          };
          return (
            null != this._file && (e.file = this._file),
            null != this._sourceRoot && (e.sourceRoot = this._sourceRoot),
            this._sourcesContents &&
              (e.sourcesContent = this._generateSourcesContent(
                e.sources,
                e.sourceRoot,
              )),
            e
          );
        }),
        (i.prototype.toString = function () {
          return JSON.stringify(this.toJSON());
        }),
        (n.SourceMapGenerator = i);
    },
    function (e, n, r) {
      var u = r(3);
      (n.encode = function (e) {
        for (
          var n,
            r = "",
            t = (function e(n) {
              return n < 0 ? 1 + (-n << 1) : 0 + (n << 1);
            })(e);
          (n = 31 & t), 0 < (t >>>= 5) && (n |= 32), (r += u.encode(n)), 0 < t;

        );
        return r;
      }),
        (n.decode = function (e, n, r) {
          var t,
            o,
            i = e.length,
            s = 0,
            a = 0;
          do {
            if (i <= n)
              throw new Error("Expected more digits in base 64 VLQ value.");
            if (-1 === (o = u.decode(e.charCodeAt(n++))))
              throw new Error("Invalid base64 digit: " + e.charAt(n - 1));
            (t = !!(32 & o)), (s += (o &= 31) << a), (a += 5);
          } while (t);
          (r.value = (function e(n) {
            var r = n >> 1;
            return 1 == (1 & n) ? -r : r;
          })(s)),
            (r.rest = n);
        });
    },
    function (e, n) {
      var r =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
          "",
        );
      (n.encode = function (e) {
        if (0 <= e && e < r.length) return r[e];
        throw new TypeError("Must be between 0 and 63: " + e);
      }),
        (n.decode = function (e) {
          return 65 <= e && e <= 90
            ? e - 65
            : 97 <= e && e <= 122
            ? e - 97 + 26
            : 48 <= e && e <= 57
            ? e - 48 + 52
            : 43 == e
            ? 62
            : 47 == e
            ? 63
            : -1;
        });
    },
    function (e, u) {
      function l(e) {
        var n = e.match(r);
        return n
          ? { scheme: n[1], auth: n[2], host: n[3], port: n[4], path: n[5] }
          : null;
      }
      function c(e) {
        var n = "";
        return (
          e.scheme && (n += e.scheme + ":"),
          (n += "//"),
          e.auth && (n += e.auth + "@"),
          e.host && (n += e.host),
          e.port && (n += ":" + e.port),
          e.path && (n += e.path),
          n
        );
      }
      function s(e) {
        var n = e,
          r = l(e);
        if (r) {
          if (!r.path) return e;
          n = r.path;
        }
        for (
          var t,
            o = u.isAbsolute(n),
            i = n.split(/\/+/),
            s = 0,
            a = i.length - 1;
          0 <= a;
          a--
        )
          "." === (t = i[a])
            ? i.splice(a, 1)
            : ".." === t
            ? s++
            : 0 < s &&
              ("" === t
                ? (i.splice(a + 1, s), (s = 0))
                : (i.splice(a, 2), s--));
        return (
          "" === (n = i.join("/")) && (n = o ? "/" : "."),
          r ? ((r.path = n), c(r)) : n
        );
      }
      function o(e, n) {
        return e === n ? 0 : n < e ? 1 : -1;
      }
      u.getArg = function e(n, r, t) {
        if (r in n) return n[r];
        if (3 === arguments.length) return t;
        throw new Error('"' + r + '" is a required argument.');
      };
      var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,
        a = /^data:.+\,.+$/;
      (u.urlParse = l),
        (u.urlGenerate = c),
        (u.normalize = s),
        (u.join = function e(n, r) {
          "" === n && (n = "."), "" === r && (r = ".");
          var t = l(r),
            o = l(n);
          if ((o && (n = o.path || "/"), t && !t.scheme))
            return o && (t.scheme = o.scheme), c(t);
          if (t || r.match(a)) return r;
          if (o && !o.host && !o.path) return (o.host = r), c(o);
          var i = "/" === r.charAt(0) ? r : s(n.replace(/\/+$/, "") + "/" + r);
          return o ? ((o.path = i), c(o)) : i;
        }),
        (u.isAbsolute = function (e) {
          return "/" === e.charAt(0) || !!e.match(r);
        }),
        (u.relative = function e(n, r) {
          "" === n && (n = "."), (n = n.replace(/\/$/, ""));
          for (var t = 0; 0 !== r.indexOf(n + "/"); ) {
            var o = n.lastIndexOf("/");
            if (o < 0) return r;
            if ((n = n.slice(0, o)).match(/^([^\/]+:\/)?\/*$/)) return r;
            ++t;
          }
          return Array(t + 1).join("../") + r.substr(n.length + 1);
        }),
        (u.toSetString = function e(n) {
          return "$" + n;
        }),
        (u.fromSetString = function e(n) {
          return n.substr(1);
        }),
        (u.compareByOriginalPositions = function e(n, r, t) {
          var o = n.source - r.source;
          return 0 !== o
            ? o
            : 0 != (o = n.originalLine - r.originalLine)
            ? o
            : 0 != (o = n.originalColumn - r.originalColumn) || t
            ? o
            : 0 != (o = n.generatedColumn - r.generatedColumn)
            ? o
            : 0 != (o = n.generatedLine - r.generatedLine)
            ? o
            : n.name - r.name;
        }),
        (u.compareByGeneratedPositionsDeflated = function e(n, r, t) {
          var o = n.generatedLine - r.generatedLine;
          return 0 !== o
            ? o
            : 0 != (o = n.generatedColumn - r.generatedColumn) || t
            ? o
            : 0 != (o = n.source - r.source)
            ? o
            : 0 != (o = n.originalLine - r.originalLine)
            ? o
            : 0 != (o = n.originalColumn - r.originalColumn)
            ? o
            : n.name - r.name;
        }),
        (u.compareByGeneratedPositionsInflated = function e(n, r) {
          var t = n.generatedLine - r.generatedLine;
          return 0 !== t
            ? t
            : 0 != (t = n.generatedColumn - r.generatedColumn)
            ? t
            : 0 !== (t = o(n.source, r.source))
            ? t
            : 0 != (t = n.originalLine - r.originalLine)
            ? t
            : 0 != (t = n.originalColumn - r.originalColumn)
            ? t
            : o(n.name, r.name);
        });
    },
    function (e, n, r) {
      function i() {
        (this._array = []), (this._set = {});
      }
      var s = r(4);
      (i.fromArray = function (e, n) {
        for (var r = new i(), t = 0, o = e.length; t < o; t++) r.add(e[t], n);
        return r;
      }),
        (i.prototype.size = function () {
          return Object.getOwnPropertyNames(this._set).length;
        }),
        (i.prototype.add = function (e, n) {
          var r = s.toSetString(e),
            t = this._set.hasOwnProperty(r),
            o = this._array.length;
          (!t || n) && this._array.push(e), t || (this._set[r] = o);
        }),
        (i.prototype.has = function (e) {
          var n = s.toSetString(e);
          return this._set.hasOwnProperty(n);
        }),
        (i.prototype.indexOf = function (e) {
          var n = s.toSetString(e);
          if (this._set.hasOwnProperty(n)) return this._set[n];
          throw new Error('"' + e + '" is not in the set.');
        }),
        (i.prototype.at = function (e) {
          if (0 <= e && e < this._array.length) return this._array[e];
          throw new Error("No element indexed by " + e);
        }),
        (i.prototype.toArray = function () {
          return this._array.slice();
        }),
        (n.ArraySet = i);
    },
    function (e, n, r) {
      function t() {
        (this._array = []),
          (this._sorted = !0),
          (this._last = { generatedLine: -1, generatedColumn: 0 });
      }
      var a = r(4);
      (t.prototype.unsortedForEach = function (e, n) {
        this._array.forEach(e, n);
      }),
        (t.prototype.add = function (e) {
          !(function e(n, r) {
            var t = n.generatedLine,
              o = r.generatedLine,
              i = n.generatedColumn,
              s = r.generatedColumn;
            return (
              t < o ||
              (o == t && i <= s) ||
              a.compareByGeneratedPositionsInflated(n, r) <= 0
            );
          })(this._last, e)
            ? (this._sorted = !1)
            : (this._last = e),
            this._array.push(e);
        }),
        (t.prototype.toArray = function () {
          return (
            this._sorted ||
              (this._array.sort(a.compareByGeneratedPositionsInflated),
              (this._sorted = !0)),
            this._array
          );
        }),
        (n.MappingList = t);
    },
    function (e, n, r) {
      function s(e) {
        var n = e;
        return (
          "string" == typeof e && (n = JSON.parse(e.replace(/^\)\]\}'/, ""))),
          null != n.sections ? new t(n) : new g(n)
        );
      }
      function g(e) {
        var n = e;
        "string" == typeof e && (n = JSON.parse(e.replace(/^\)\]\}'/, "")));
        var r = C.getArg(n, "version"),
          t = C.getArg(n, "sources"),
          o = C.getArg(n, "names", []),
          i = C.getArg(n, "sourceRoot", null),
          s = C.getArg(n, "sourcesContent", null),
          a = C.getArg(n, "mappings"),
          u = C.getArg(n, "file", null);
        if (r != this._version) throw new Error("Unsupported version: " + r);
        (t = t.map(C.normalize).map(function (e) {
          return i && C.isAbsolute(i) && C.isAbsolute(e) ? C.relative(i, e) : e;
        })),
          (this._names = p.fromArray(o, !0)),
          (this._sources = p.fromArray(t, !0)),
          (this.sourceRoot = i),
          (this.sourcesContent = s),
          (this._mappings = a),
          (this.file = u);
      }
      function y() {
        (this.generatedLine = 0),
          (this.generatedColumn = 0),
          (this.source = null),
          (this.originalLine = null),
          (this.originalColumn = null),
          (this.name = null);
      }
      function t(e) {
        var n = e;
        "string" == typeof e && (n = JSON.parse(e.replace(/^\)\]\}'/, "")));
        var r = C.getArg(n, "version"),
          t = C.getArg(n, "sections");
        if (r != this._version) throw new Error("Unsupported version: " + r);
        (this._sources = new p()), (this._names = new p());
        var o = { line: -1, column: 0 };
        this._sections = t.map(function (e) {
          if (e.url)
            throw new Error(
              "Support for url field in sections not implemented.",
            );
          var n = C.getArg(e, "offset"),
            r = C.getArg(n, "line"),
            t = C.getArg(n, "column");
          if (r < o.line || (r === o.line && t < o.column))
            throw new Error(
              "Section offsets must be ordered and non-overlapping.",
            );
          return (
            (o = n),
            {
              generatedOffset: { generatedLine: r + 1, generatedColumn: t + 1 },
              consumer: new s(C.getArg(e, "map")),
            }
          );
        });
      }
      var C = r(4),
        u = r(8),
        p = r(5).ArraySet,
        A = r(2),
        S = r(9).quickSort;
      (s.fromSourceMap = function (e) {
        return g.fromSourceMap(e);
      }),
        (s.prototype._version = 3),
        (s.prototype.__generatedMappings = null),
        Object.defineProperty(s.prototype, "_generatedMappings", {
          get: function () {
            return (
              this.__generatedMappings ||
                this._parseMappings(this._mappings, this.sourceRoot),
              this.__generatedMappings
            );
          },
        }),
        (s.prototype.__originalMappings = null),
        Object.defineProperty(s.prototype, "_originalMappings", {
          get: function () {
            return (
              this.__originalMappings ||
                this._parseMappings(this._mappings, this.sourceRoot),
              this.__originalMappings
            );
          },
        }),
        (s.prototype._charIsMappingSeparator = function (e, n) {
          var r = e.charAt(n);
          return ";" === r || "," === r;
        }),
        (s.prototype._parseMappings = function (e, n) {
          throw new Error("Subclasses must implement _parseMappings");
        }),
        (s.GENERATED_ORDER = 1),
        (s.ORIGINAL_ORDER = 2),
        (s.GREATEST_LOWER_BOUND = 1),
        (s.LEAST_UPPER_BOUND = 2),
        (s.prototype.eachMapping = function (e, n, r) {
          var t,
            o = n || null;
          switch (r || s.GENERATED_ORDER) {
            case s.GENERATED_ORDER:
              t = this._generatedMappings;
              break;
            case s.ORIGINAL_ORDER:
              t = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var i = this.sourceRoot;
          t.map(function (e) {
            var n = null === e.source ? null : this._sources.at(e.source);
            return (
              null != n && null != i && (n = C.join(i, n)),
              {
                source: n,
                generatedLine: e.generatedLine,
                generatedColumn: e.generatedColumn,
                originalLine: e.originalLine,
                originalColumn: e.originalColumn,
                name: null === e.name ? null : this._names.at(e.name),
              }
            );
          }, this).forEach(e, o);
        }),
        (s.prototype.allGeneratedPositionsFor = function (e) {
          var n = C.getArg(e, "line"),
            r = {
              source: C.getArg(e, "source"),
              originalLine: n,
              originalColumn: C.getArg(e, "column", 0),
            };
          if (
            (null != this.sourceRoot &&
              (r.source = C.relative(this.sourceRoot, r.source)),
            !this._sources.has(r.source))
          )
            return [];
          r.source = this._sources.indexOf(r.source);
          var t = [],
            o = this._findMapping(
              r,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              C.compareByOriginalPositions,
              u.LEAST_UPPER_BOUND,
            );
          if (0 <= o) {
            var i = this._originalMappings[o];
            if (void 0 === e.column)
              for (var s = i.originalLine; i && i.originalLine === s; )
                t.push({
                  line: C.getArg(i, "generatedLine", null),
                  column: C.getArg(i, "generatedColumn", null),
                  lastColumn: C.getArg(i, "lastGeneratedColumn", null),
                }),
                  (i = this._originalMappings[++o]);
            else
              for (
                var a = i.originalColumn;
                i && i.originalLine === n && i.originalColumn == a;

              )
                t.push({
                  line: C.getArg(i, "generatedLine", null),
                  column: C.getArg(i, "generatedColumn", null),
                  lastColumn: C.getArg(i, "lastGeneratedColumn", null),
                }),
                  (i = this._originalMappings[++o]);
          }
          return t;
        }),
        (n.SourceMapConsumer = s),
        ((g.prototype = Object.create(s.prototype)).consumer = s),
        (g.fromSourceMap = function (e) {
          var n = Object.create(g.prototype),
            r = (n._names = p.fromArray(e._names.toArray(), !0)),
            t = (n._sources = p.fromArray(e._sources.toArray(), !0));
          (n.sourceRoot = e._sourceRoot),
            (n.sourcesContent = e._generateSourcesContent(
              n._sources.toArray(),
              n.sourceRoot,
            )),
            (n.file = e._file);
          for (
            var o = e._mappings.toArray().slice(),
              i = (n.__generatedMappings = []),
              s = (n.__originalMappings = []),
              a = 0,
              u = o.length;
            a < u;
            a++
          ) {
            var l = o[a],
              c = new y();
            (c.generatedLine = l.generatedLine),
              (c.generatedColumn = l.generatedColumn),
              l.source &&
                ((c.source = t.indexOf(l.source)),
                (c.originalLine = l.originalLine),
                (c.originalColumn = l.originalColumn),
                l.name && (c.name = r.indexOf(l.name)),
                s.push(c)),
              i.push(c);
          }
          return S(n.__originalMappings, C.compareByOriginalPositions), n;
        }),
        (g.prototype._version = 3),
        Object.defineProperty(g.prototype, "sources", {
          get: function () {
            return this._sources.toArray().map(function (e) {
              return null != this.sourceRoot ? C.join(this.sourceRoot, e) : e;
            }, this);
          },
        }),
        (g.prototype._parseMappings = function (e, n) {
          for (
            var r,
              t,
              o,
              i,
              s,
              a = 1,
              u = 0,
              l = 0,
              c = 0,
              g = 0,
              p = 0,
              h = e.length,
              f = 0,
              d = {},
              m = {},
              _ = [],
              v = [];
            f < h;

          )
            if (";" === e.charAt(f)) a++, f++, (u = 0);
            else if ("," === e.charAt(f)) f++;
            else {
              for (
                (r = new y()).generatedLine = a, i = f;
                i < h && !this._charIsMappingSeparator(e, i);
                i++
              );
              if ((o = d[(t = e.slice(f, i))])) f += t.length;
              else {
                for (o = []; f < i; )
                  A.decode(e, f, m), (s = m.value), (f = m.rest), o.push(s);
                if (2 === o.length)
                  throw new Error("Found a source, but no line and column");
                if (3 === o.length)
                  throw new Error("Found a source and line, but no column");
                d[t] = o;
              }
              (r.generatedColumn = u + o[0]),
                (u = r.generatedColumn),
                1 < o.length &&
                  ((r.source = g + o[1]),
                  (g += o[1]),
                  (r.originalLine = l + o[2]),
                  (l = r.originalLine),
                  (r.originalLine += 1),
                  (r.originalColumn = c + o[3]),
                  (c = r.originalColumn),
                  4 < o.length && ((r.name = p + o[4]), (p += o[4]))),
                v.push(r),
                "number" == typeof r.originalLine && _.push(r);
            }
          S(v, C.compareByGeneratedPositionsDeflated),
            (this.__generatedMappings = v),
            S(_, C.compareByOriginalPositions),
            (this.__originalMappings = _);
        }),
        (g.prototype._findMapping = function (e, n, r, t, o, i) {
          if (e[r] <= 0)
            throw new TypeError(
              "Line must be greater than or equal to 1, got " + e[r],
            );
          if (e[t] < 0)
            throw new TypeError(
              "Column must be greater than or equal to 0, got " + e[t],
            );
          return u.search(e, n, o, i);
        }),
        (g.prototype.computeColumnSpans = function () {
          for (var e = 0; e < this._generatedMappings.length; ++e) {
            var n = this._generatedMappings[e];
            if (e + 1 < this._generatedMappings.length) {
              var r = this._generatedMappings[e + 1];
              if (n.generatedLine === r.generatedLine) {
                n.lastGeneratedColumn = r.generatedColumn - 1;
                continue;
              }
            }
            n.lastGeneratedColumn = 1 / 0;
          }
        }),
        (g.prototype.originalPositionFor = function (e) {
          var n = {
              generatedLine: C.getArg(e, "line"),
              generatedColumn: C.getArg(e, "column"),
            },
            r = this._findMapping(
              n,
              this._generatedMappings,
              "generatedLine",
              "generatedColumn",
              C.compareByGeneratedPositionsDeflated,
              C.getArg(e, "bias", s.GREATEST_LOWER_BOUND),
            );
          if (0 <= r) {
            var t = this._generatedMappings[r];
            if (t.generatedLine === n.generatedLine) {
              var o = C.getArg(t, "source", null);
              null !== o &&
                ((o = this._sources.at(o)),
                null != this.sourceRoot && (o = C.join(this.sourceRoot, o)));
              var i = C.getArg(t, "name", null);
              return (
                null !== i && (i = this._names.at(i)),
                {
                  source: o,
                  line: C.getArg(t, "originalLine", null),
                  column: C.getArg(t, "originalColumn", null),
                  name: i,
                }
              );
            }
          }
          return { source: null, line: null, column: null, name: null };
        }),
        (g.prototype.hasContentsOfAllSources = function () {
          return (
            !!this.sourcesContent &&
            this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (e) {
              return null == e;
            })
          );
        }),
        (g.prototype.sourceContentFor = function (e, n) {
          if (!this.sourcesContent) return null;
          if (
            (null != this.sourceRoot && (e = C.relative(this.sourceRoot, e)),
            this._sources.has(e))
          )
            return this.sourcesContent[this._sources.indexOf(e)];
          var r;
          if (null != this.sourceRoot && (r = C.urlParse(this.sourceRoot))) {
            var t = e.replace(/^file:\/\//, "");
            if ("file" == r.scheme && this._sources.has(t))
              return this.sourcesContent[this._sources.indexOf(t)];
            if ((!r.path || "/" == r.path) && this._sources.has("/" + e))
              return this.sourcesContent[this._sources.indexOf("/" + e)];
          }
          if (n) return null;
          throw new Error('"' + e + '" is not in the SourceMap.');
        }),
        (g.prototype.generatedPositionFor = function (e) {
          var n = C.getArg(e, "source");
          if (
            (null != this.sourceRoot && (n = C.relative(this.sourceRoot, n)),
            !this._sources.has(n))
          )
            return { line: null, column: null, lastColumn: null };
          var r = {
              source: (n = this._sources.indexOf(n)),
              originalLine: C.getArg(e, "line"),
              originalColumn: C.getArg(e, "column"),
            },
            t = this._findMapping(
              r,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              C.compareByOriginalPositions,
              C.getArg(e, "bias", s.GREATEST_LOWER_BOUND),
            );
          if (0 <= t) {
            var o = this._originalMappings[t];
            if (o.source === r.source)
              return {
                line: C.getArg(o, "generatedLine", null),
                column: C.getArg(o, "generatedColumn", null),
                lastColumn: C.getArg(o, "lastGeneratedColumn", null),
              };
          }
          return { line: null, column: null, lastColumn: null };
        }),
        (n.BasicSourceMapConsumer = g),
        ((t.prototype = Object.create(s.prototype)).constructor = s),
        (t.prototype._version = 3),
        Object.defineProperty(t.prototype, "sources", {
          get: function () {
            for (var e = [], n = 0; n < this._sections.length; n++)
              for (
                var r = 0;
                r < this._sections[n].consumer.sources.length;
                r++
              )
                e.push(this._sections[n].consumer.sources[r]);
            return e;
          },
        }),
        (t.prototype.originalPositionFor = function (e) {
          var n = {
              generatedLine: C.getArg(e, "line"),
              generatedColumn: C.getArg(e, "column"),
            },
            r = u.search(n, this._sections, function (e, n) {
              var r = e.generatedLine - n.generatedOffset.generatedLine;
              return r || e.generatedColumn - n.generatedOffset.generatedColumn;
            }),
            t = this._sections[r];
          return t
            ? t.consumer.originalPositionFor({
                line: n.generatedLine - (t.generatedOffset.generatedLine - 1),
                column:
                  n.generatedColumn -
                  (t.generatedOffset.generatedLine === n.generatedLine
                    ? t.generatedOffset.generatedColumn - 1
                    : 0),
                bias: e.bias,
              })
            : { source: null, line: null, column: null, name: null };
        }),
        (t.prototype.hasContentsOfAllSources = function () {
          return this._sections.every(function (e) {
            return e.consumer.hasContentsOfAllSources();
          });
        }),
        (t.prototype.sourceContentFor = function (e, n) {
          for (var r = 0; r < this._sections.length; r++) {
            var t = this._sections[r].consumer.sourceContentFor(e, !0);
            if (t) return t;
          }
          if (n) return null;
          throw new Error('"' + e + '" is not in the SourceMap.');
        }),
        (t.prototype.generatedPositionFor = function (e) {
          for (var n = 0; n < this._sections.length; n++) {
            var r = this._sections[n];
            if (-1 !== r.consumer.sources.indexOf(C.getArg(e, "source"))) {
              var t = r.consumer.generatedPositionFor(e);
              if (t)
                return {
                  line: t.line + (r.generatedOffset.generatedLine - 1),
                  column:
                    t.column +
                    (r.generatedOffset.generatedLine === t.line
                      ? r.generatedOffset.generatedColumn - 1
                      : 0),
                };
            }
          }
          return { line: null, column: null };
        }),
        (t.prototype._parseMappings = function (e, n) {
          (this.__generatedMappings = []), (this.__originalMappings = []);
          for (var r = 0; r < this._sections.length; r++)
            for (
              var t = this._sections[r],
                o = t.consumer._generatedMappings,
                i = 0;
              i < o.length;
              i++
            ) {
              var s = o[i],
                a = t.consumer._sources.at(s.source);
              null !== t.consumer.sourceRoot &&
                (a = C.join(t.consumer.sourceRoot, a)),
                this._sources.add(a),
                (a = this._sources.indexOf(a));
              var u = t.consumer._names.at(s.name);
              this._names.add(u), (u = this._names.indexOf(u));
              var l = {
                source: a,
                generatedLine:
                  s.generatedLine + (t.generatedOffset.generatedLine - 1),
                generatedColumn:
                  s.generatedColumn +
                  (t.generatedOffset.generatedLine === s.generatedLine
                    ? t.generatedOffset.generatedColumn - 1
                    : 0),
                originalLine: s.originalLine,
                originalColumn: s.originalColumn,
                name: u,
              };
              this.__generatedMappings.push(l),
                "number" == typeof l.originalLine &&
                  this.__originalMappings.push(l);
            }
          S(this.__generatedMappings, C.compareByGeneratedPositionsDeflated),
            S(this.__originalMappings, C.compareByOriginalPositions);
        }),
        (n.IndexedSourceMapConsumer = t);
    },
    function (e, l) {
      (l.GREATEST_LOWER_BOUND = 1),
        (l.LEAST_UPPER_BOUND = 2),
        (l.search = function (e, n, r, t) {
          if (0 === n.length) return -1;
          var o = (function e(n, r, t, o, i, s) {
            var a = Math.floor((r - n) / 2) + n,
              u = i(t, o[a], !0);
            return 0 === u
              ? a
              : 0 < u
              ? 1 < r - a
                ? e(a, r, t, o, i, s)
                : s == l.LEAST_UPPER_BOUND
                ? r < o.length
                  ? r
                  : -1
                : a
              : 1 < a - n
              ? e(n, a, t, o, i, s)
              : s == l.LEAST_UPPER_BOUND
              ? a
              : n < 0
              ? -1
              : n;
          })(-1, n.length, e, n, r, t || l.GREATEST_LOWER_BOUND);
          if (o < 0) return -1;
          for (; 0 <= o - 1 && 0 === r(n[o], n[o - 1], !0); ) --o;
          return o;
        });
    },
    function (e, n) {
      function u(e, n, r) {
        var t = e[n];
        (e[n] = e[r]), (e[r] = t);
      }
      function l(e, n, r, t) {
        if (r < t) {
          var o = r - 1;
          u(
            e,
            (function e(n, r) {
              return Math.round(n + Math.random() * (r - n));
            })(r, t),
            t,
          );
          for (var i = e[t], s = r; s < t; s++)
            n(e[s], i) <= 0 && u(e, (o += 1), s);
          u(e, o + 1, s);
          var a = o + 1;
          l(e, n, r, a - 1), l(e, n, a + 1, t);
        }
      }
      n.quickSort = function (e, n) {
        l(e, n, 0, e.length - 1);
      };
    },
    function (e, n, r) {
      function g(e, n, r, t, o) {
        (this.children = []),
          (this.sourceContents = {}),
          (this.line = null == e ? null : e),
          (this.column = null == n ? null : n),
          (this.source = null == r ? null : r),
          (this.name = null == o ? null : o),
          (this[i] = !0),
          null != t && this.add(t);
      }
      var t = r(1).SourceMapGenerator,
        p = r(4),
        h = /(\r?\n)/,
        i = "$$$isSourceNode$$$";
      (g.fromStringWithSourceMap = function (e, r, t) {
        function o(e, n) {
          if (null === e || void 0 === e.source) i.add(n);
          else {
            var r = t ? p.join(t, e.source) : e.source;
            i.add(new g(e.originalLine, e.originalColumn, r, n, e.name));
          }
        }
        var i = new g(),
          s = e.split(h),
          a = function () {
            return s.shift() + (s.shift() || "");
          },
          u = 1,
          l = 0,
          c = null;
        return (
          r.eachMapping(function (e) {
            if (null !== c) {
              if (!(u < e.generatedLine)) {
                var n = (r = s[0]).substr(0, e.generatedColumn - l);
                return (
                  (s[0] = r.substr(e.generatedColumn - l)),
                  (l = e.generatedColumn),
                  o(c, n),
                  void (c = e)
                );
              }
              o(c, a()), u++, (l = 0);
            }
            for (; u < e.generatedLine; ) i.add(a()), u++;
            if (l < e.generatedColumn) {
              var r = s[0];
              i.add(r.substr(0, e.generatedColumn)),
                (s[0] = r.substr(e.generatedColumn)),
                (l = e.generatedColumn);
            }
            c = e;
          }, this),
          0 < s.length && (c && o(c, a()), i.add(s.join(""))),
          r.sources.forEach(function (e) {
            var n = r.sourceContentFor(e);
            null != n &&
              (null != t && (e = p.join(t, e)), i.setSourceContent(e, n));
          }),
          i
        );
      }),
        (g.prototype.add = function (e) {
          if (Array.isArray(e))
            e.forEach(function (e) {
              this.add(e);
            }, this);
          else {
            if (!e[i] && "string" != typeof e)
              throw new TypeError(
                "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                  e,
              );
            e && this.children.push(e);
          }
          return this;
        }),
        (g.prototype.prepend = function (e) {
          if (Array.isArray(e))
            for (var n = e.length - 1; 0 <= n; n--) this.prepend(e[n]);
          else {
            if (!e[i] && "string" != typeof e)
              throw new TypeError(
                "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                  e,
              );
            this.children.unshift(e);
          }
          return this;
        }),
        (g.prototype.walk = function (e) {
          for (var n, r = 0, t = this.children.length; r < t; r++)
            (n = this.children[r])[i]
              ? n.walk(e)
              : "" !== n &&
                e(n, {
                  source: this.source,
                  line: this.line,
                  column: this.column,
                  name: this.name,
                });
        }),
        (g.prototype.join = function (e) {
          var n,
            r,
            t = this.children.length;
          if (0 < t) {
            for (n = [], r = 0; r < t - 1; r++)
              n.push(this.children[r]), n.push(e);
            n.push(this.children[r]), (this.children = n);
          }
          return this;
        }),
        (g.prototype.replaceRight = function (e, n) {
          var r = this.children[this.children.length - 1];
          return (
            r[i]
              ? r.replaceRight(e, n)
              : "string" == typeof r
              ? (this.children[this.children.length - 1] = r.replace(e, n))
              : this.children.push("".replace(e, n)),
            this
          );
        }),
        (g.prototype.setSourceContent = function (e, n) {
          this.sourceContents[p.toSetString(e)] = n;
        }),
        (g.prototype.walkSourceContents = function (e) {
          for (var n = 0, r = this.children.length; n < r; n++)
            this.children[n][i] && this.children[n].walkSourceContents(e);
          var t = Object.keys(this.sourceContents);
          for (n = 0, r = t.length; n < r; n++)
            e(p.fromSetString(t[n]), this.sourceContents[t[n]]);
        }),
        (g.prototype.toString = function () {
          var n = "";
          return (
            this.walk(function (e) {
              n += e;
            }),
            n
          );
        }),
        (g.prototype.toStringWithSourceMap = function (e) {
          var o = { code: "", line: 1, column: 0 },
            i = new t(e),
            s = !1,
            a = null,
            u = null,
            l = null,
            c = null;
          return (
            this.walk(function (e, n) {
              (o.code += e),
                null !== n.source && null !== n.line && null !== n.column
                  ? ((a !== n.source ||
                      u !== n.line ||
                      l !== n.column ||
                      c !== n.name) &&
                      i.addMapping({
                        source: n.source,
                        original: { line: n.line, column: n.column },
                        generated: { line: o.line, column: o.column },
                        name: n.name,
                      }),
                    (a = n.source),
                    (u = n.line),
                    (l = n.column),
                    (c = n.name),
                    (s = !0))
                  : s &&
                    (i.addMapping({
                      generated: { line: o.line, column: o.column },
                    }),
                    (a = null),
                    (s = !1));
              for (var r = 0, t = e.length; r < t; r++)
                10 === e.charCodeAt(r)
                  ? (o.line++,
                    (o.column = 0),
                    r + 1 === t
                      ? ((a = null), (s = !1))
                      : s &&
                        i.addMapping({
                          source: n.source,
                          original: { line: n.line, column: n.column },
                          generated: { line: o.line, column: o.column },
                          name: n.name,
                        }))
                  : o.column++;
            }),
            this.walkSourceContents(function (e, n) {
              i.setSourceContent(e, n);
            }),
            { code: o.code, map: i }
          );
        }),
        (n.SourceNode = g);
    },
  ]),
);
